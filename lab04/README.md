# 高级密码学实验四任务说明

## 实验概览

- 实现一个基于 9x9 数独的交互式零知识证明协议。Prover 随机生成带解的数独题目，并通过哈希承诺 + 随机挑战的方式，在多轮交互中向 Verifier 证明自己掌握正确解答。
- 实现 Schnorr 签名方案


### 原理简介（零知识证明）

1. **承诺阶段（Commitment）**
   - Prover 将解答中的每个格子随机重标记（数字置换）。
   - 使用随机值 + 置换后的数字计算 SHA-256 承诺，发送一个"看不出内容"的哈希矩阵给 Verifier。
   - 同时对数字置换（1→?、2→? …）也分别承诺。

2. **挑战阶段（Challenge）**
   - Verifier 随机选择挑战类型：
     - `ROW`：指定一行
     - `COL`：指定一列
     - `BOX`：指定一个 3×3 小宫
     - `CLUE`：指定题面线索格子
   - 这些挑战对应于数独的约束，旨在检测 Prover 是否真正掌握解答。

3. **揭示阶段（Response）**
   - `ROW/COL/BOX`：Prover 揭示被选行/列/格子的置换后的数字，Verifier 校验哈希承诺并检查数字唯一性。
   - `CLUE`：Prover 揭示线索格子的随机值和选取的数字置换，Verifier 校验承诺并验证这些线索的映射，其它格子仍处于承诺状态，无法得知具体数字。
   - 其余未被挑战的格子仍保持承诺状态。

4. **重复轮数**
   - 单轮只能确保 Prover 未作弊的概率较低，通过独立重复多轮（本实验默认 10 轮）使 Prover 欺骗的概率指数级下降。
   - 整个过程 Prover 仅在 Verifier 发出特定挑战时才揭示对应信息，其余格子仍然保持承诺状态，从而不会泄露完整解或数字置换映射。

#### 术语说明

- **clue（线索）**：指题面上原本就公开的格子（例如给定的数字）。在协议中，CLUE 挑战会要求 Prover 打开所有这些格子的承诺，并同步揭示当前轮次的数字映射，以证明题面与承诺一致，而不会影响其它未知格子的隐藏性。


### Schnorr签名实现原理
#### 密钥生成
1. 在 `[1, n-1]` 范围内选择随机私钥 `x`（`n` 为曲线阶）
2. 计算公钥 `P = x * G`（`G` 为生成元）

#### 签名
1. 生成随机 `k` 并计算 `R = k * G`
2. 取 `R` 的 x 坐标得到 `r`
3. 计算挑战 `e = H(r || P || m)`
4. 计算 `s = k - e * x (mod n)`
5. 签名对为 `(r, s)`

#### 验证
1. 重新计算 `e = H(r || P || m)`
2. 计算 `R' = sG + eP`
3. 比较 `R'` 的 x 坐标是否等于 `r`

#### 安全参数

- 椭圆曲线：`secp256k1`
- 哈希函数：`SHA-256`
- 密钥长度：256 位

### 实验任务

#### 数独零知识证明协议实现

在本次实验中，你需要参考 `prover_output.txt` 和 `verifier_output.txt` 中提供的协议交互日志，实现零知识证明协议（不需要与交互日志一模一样，可以适当调整）。核心组件可包括：
   - 数独生成器 (Sudoku Generator)
   - 承诺系统 (Commitment System) 
   - 挑战生成器 (Challenge Generator)
   - 验证者 (Verifier)
   - 证明者 (Prover)
   - 网络通信组件 (Network Communication)

#### Schnorr签名实现
1. 补全 schnorr_signature.cpp 中函数 `generateKeyPair` `sign` `verify`

### 实验指南

**数独生成器实现提示**：数独生成器需要创建一个有效的9×9数独解，可以通过基础模式和随机变换来实现：
   - **基础模式算法**：使用公式 `(kBoxSize * (row % kBoxSize) + row / kBoardSize + col) % kBoardSize` 生成基础模式，对9×9数独，kBoxSize=3，kBoardSize=9
     * 此公式产生一个数学规律性模式，确保每行、每列、每个3×3宫都包含从0到8（或1到9）的所有数字
     * 例如，第0行的数字模式为：0,1,2,3,4,5,6,7,8；第1行的模式为：3,4,5,6,7,8,0,1,2
   - **完整解生成算法**：为了生成随机的有效数独解，需要对基础模式进行多个变换：
     * 步骤1 - 随机打乱行带：将9行分为3个行带（第0-2行、第3-5行、第6-8行），随机重排这3个行带的顺序
     * 步骤2 - 随机打乱列带：将9列分为3个列带（第0-2列、第3-5列、第6-8列），随机重排这3个列带的顺序
     * 步骤3 - 随机打乱行内顺序：在每个3×3行带内部，对3行进行随机重排（例如在第0-2行的行带内，将行0、1、2按随机顺序重排）
     * 步骤4 - 随机打乱列内顺序：在每个3×3列带内部，对3列进行随机重排（例如在第0-2列的列带内，将列0、1、2按随机顺序重排）
     * 步骤5 - 随机数字映射：对1-9（或者0-8）的数字进行随机映射（如1→5, 2→3, 3→9等），确保解的随机性
     * 步骤6 - 可选变换：对整个棋盘进行旋转或镜像翻转以增加随机性（如旋转90度、180度、270度，或水平/垂直翻转）
   - **生成题目**：从完整解中随机挖掉部分格子形成题目，保留的数字作为线索：
     * 从完整解中随机选择要挖掉的位置
     * 通常保留20-35个线索数字以确保题目可解性与挑战性（本次实验可统一保留30个线索）

### 使用方式

#### 数独零知识证明协议

1. **启动验证方**

   ```bash
   ./verifier [--port 端口] [--rounds 轮数]
   ```

   - `--rounds`：交互轮数，默认为 10。

2. **启动证明方**（在验证方启动后执行）

   ```bash
   ./prover [--host 主机] [--port 端口] [--rounds 轮数] [--clues 线索数量]
   ```

   - `--clues`：生成题面时保留的已知数字数量，默认为 30。
   - `--rounds`：需与 Verifier 配置一致。

3. **交互流程**

   - Prover 会先随机生成一个可解的数独，同时打印带空格的题面与完整解答；随后发送题面给 Verifier。
   - Prover 在每轮随机置换后，会输出该轮的数字映射 `orig->mapped` 以及整张棋盘的"Mapping result board"（`原值->映射值`，方括号表示题面线索）。
   - Verifier 每轮随机挑选"行 / 列 / 宫 / 线索"其中一种挑战。只有在发起线索（CLUE）挑战时，Prover 才揭示指定线索格子的随机值与数字映射；Verifier 会看到带括号标注的线索格子（`orig->mapped`），其它未知格子仍然以占位符显示。行/列/宫挑战只揭示承诺值，不泄露映射。
   - Verifier 对揭示内容进行哈希校验，并确认行/列/宫满足数字唯一性。
   - 所有轮次通过后，Verifier 输出"Proof accepted"。

#### Schnorr签名

**构建与运行**
```bash
mkdir -p build
cd build
cmake ..
cmake --build .
./schnorr_demo
```


---

## 其他提示
- 允许在实验中合理使用 AI 或开源代码，但若使用请在实验报告中注明来源以及具体使用的方式等。
- 代码模板仅供参考，可以根据需要重构或添加辅助工具。

---

## 提交指南
1. **提交内容**
   - 实验报告（PDF）
   - 实验源代码压缩包（ZIP，仅包含源文件，排除中间产物与可执行文件）
2. **命名格式**
   - 邮件主题与两个附件统一为：`学号_姓名_实验课日期`
   - 示例：`202300001_张三_20250928`
3. **发送方式**
   - 单独发送一封邮件，附件含 1 份 PDF + 1 个 ZIP
   - 收件邮箱：`cryptojnu@gmail.com`
4. **截止时间**
   - 2025 年 11 月 24 日 23:59（逾期不计成绩）
5. **实验报告建议内容**
   - 基本信息：学号、姓名、实验课日期
   - 实验题目概述、实验内容与结果
   - 程序结构与关键方法说明
   - 完整代码（可附简要注释）
   - 编译指令、运行截图（需显示结果）

